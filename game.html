<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anthony Huang - Code Journey for Kids!</title>

    <!-- Google AdSense script -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8446133991523587"
        crossorigin="anonymous"></script>

    <!-- Google Tag Manager/Global Site Tag consent setup and script -->
    <script>
        // Define dataLayer and the gtag function.
        window.dataLayer = window.dataLayer || [];
        function gtag() {
            dataLayer.push(arguments);
        }

        // Set default consent to 'denied' for all categories.
        // This ensures a privacy-first approach before user interaction.
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'personalization_storage': 'denied',
            'functionality_storage': 'denied',
            'security_storage': 'denied',
            'wait_for_update': 500 // Wait for CMP to update consent (in milliseconds)
        });

        // Load the Google Tag Manager/Global Site Tag script.
        // Replace 'G-XXXXXXX' with your actual Google Analytics 4 Measurement ID
        // or 'AW-XXXXXXX' for Google Ads Conversion ID if you use those.
        // The Google Certified CMP will typically manage the loading of the consent dialog.
        // For the full CMP script, you will generate it from your AdSense/Ad Manager/GA4 account.
        (function (w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start': new Date().getTime(),
                event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src =
                'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-XXXXXX'); // Replace GTM-XXXXXX with your GTM ID or appropriate Google tag ID
    </script>

    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- FAVICON: Add these lines for your website icon -->
    <link rel="icon" type="image/png" href="https://placehold.co/32x32/48CAE4/ffffff?text=AH" sizes="32x32">
    <link rel="apple-touch-icon" href="https://placehold.co/180x180/48CAE4/ffffff?text=AH" sizes="180x180">
    <link rel="icon" type="image/x-icon" href="https://placehold.co/16x16/48CAE4/ffffff?text=AH">

    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX transformation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* A subtle animation for the robot */
        @keyframes bounce-slight {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }
        .animate-bounce-slight {
            animation: bounce-slight 1.5s infinite ease-in-out;
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) - recommended to be placed immediately after the opening <body> tag -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-XXXXXX"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="root"></div> <!-- This is where your React app will be mounted -->

    <script type="text/babel">
        const { useState, useEffect, useRef } = React; // Destructure React hooks

        // Utility to convert base64 to ArrayBuffer for audio
        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        // Utility to convert PCM to WAV format
        const pcmToWav = (pcmData, sampleRate) => {
            const numChannels = 1; // Mono audio
            const bytesPerSample = 2; // 16-bit PCM
            const buffer = new ArrayBuffer(44 + pcmData.length * bytesPerSample);
            const view = new DataView(buffer);

            // RIFF identifier
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * bytesPerSample, true);
            writeString(view, 8, 'WAVE');
            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
            view.setUint16(32, numChannels * bytesPerSample, true);
            view.setUint16(34, bytesPerSample * 8, true); // Bits per sample
            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * bytesPerSample, true);

            // Write the PCM data
            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true);
                offset += bytesPerSample;
            }

            return new Blob([view], { type: 'audio/wav' });
        };

        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        const GRID_SIZE = 10; // The game board will be a 10x10 grid

        // Defines the change in row (dr) and column (dc) for each direction.
        // 0: Up (North), 1: Right (East), 2: Down (South), 3: Left (West)
        const DIRECTIONS = [
            { dr: -1, dc: 0 }, // Up
            { dr: 0, dc: 1 },  // Right
            { dr: 1, dc: 0 },  // Down
            { dr: 0, dc: -1 }, // Left
        ];

        // Main App component for the coding game
        function App() {
            // State variables for the game
            const [grid, setGrid] = useState([]); // Represents the game board (0: path, 1: wall)
            const [characterPos, setCharacterPos] = useState({ r: 0, c: 0 }); // Robot's current row and column
            const [characterDir, setCharacterDir] = useState(1); // Robot's current direction (index from DIRECTIONS array)
            const [targetPos, setTargetPos] = useState({ r: GRID_SIZE - 1, c: GRID_SIZE - 1 }); // Star's position
            const [message, setMessage] = useState("Guide the robot to the star!"); // Messages displayed to the user
            const [commandsInput, setCommandsInput] = useState(""); // User's input for commands
            const [isLoading, setIsLoading] = useState(false); // To show loading state for TTS

            const gameRef = useRef(null); // Ref for the main game container for potential responsiveness adjustments

            // useEffect to initialize the game when the component mounts
            useEffect(() => {
                initializeGame();
            }, []); // Empty dependency array means this runs once on mount

            // Function to set up the initial game state
            const initializeGame = () => {
                // Create an empty grid
                const initialGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

                // Generate a simple maze with diagonal walls to make a path
                // This creates some obstacles but ensures a general path is available.
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        // Create a diagonal wall pattern for simplicity
                        if ((r + c) % 3 === 0 && r !== 0 && c !== 0 && !(r === GRID_SIZE - 1 && c === GRID_SIZE - 1)) {
                            initialGrid[r][c] = 1; // Mark as wall
                        }
                    }
                }

                // Ensure the start and end points are always clear of walls
                initialGrid[0][0] = 0;
                initialGrid[GRID_SIZE - 1][GRID_SIZE - 1] = 0;

                // Update state to reset the game
                setGrid(initialGrid);
                setCharacterPos({ r: 0, c: 0 }); // Robot starts at top-left
                setCharacterDir(1); // Robot starts facing East
                setTargetPos({ r: GRID_SIZE - 1, c: GRID_SIZE - 1 }); // Star is at bottom-right
                setMessage("Guide the robot to the star!");
                setCommandsInput(""); // Clear command input
            };

            // Function to generate speech from text using Gemini API
            const speakMessage = async (text) => {
                setIsLoading(true); // Set loading state
                const payload = {
                    contents: [{
                        parts: [{ text: `Say cheerfully: ${text}` }] // Request a cheerful tone
                    }],
                    generationConfig: {
                        responseModalities: ["AUDIO"], // We want audio back
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Puck" } // Use an upbeat voice named "Puck"
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts" // Specify the TTS model
                };

                const apiKey = ""; // API key will be provided by the environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                let response;
                let result;
                let attempts = 0;
                const maxAttempts = 5; // Max retries for API call
                const initialDelay = 1000; // Initial delay for exponential backoff (1 second)

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        result = await response.json(); // Parse the JSON response

                        const part = result?.candidates?.[0]?.content?.parts?.[0];
                        const audioData = part?.inlineData?.data; // Base64 encoded audio data
                        const mimeType = part?.inlineData?.mimeType; // Mime type of the audio

                        if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                            // Extract sample rate from mime type, default to 16000 if not found
                            const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                            const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;

                            const pcmData = base64ToArrayBuffer(audioData); // Convert base64 to ArrayBuffer
                            const pcm16 = new Int16Array(pcmData); // Create Int16Array from PCM data
                            const wavBlob = pcmToWav(pcm16, sampleRate); // Convert PCM to WAV Blob
                            const audioUrl = URL.createObjectURL(wavBlob); // Create a URL for the audio Blob

                            const audio = new Audio(audioUrl); // Create an Audio object
                            audio.play(); // Play the audio
                            setIsLoading(false); // Reset loading state
                            return;
                        } else {
                            console.error("Unexpected TTS response structure or missing audio content:", result);
                            setIsLoading(false);
                            return;
                        }
                    } catch (error) {
                        // Handle rate limiting (429 Too Many Requests) with exponential backoff
                        if (error.message.includes("429")) {
                            attempts++;
                            const delay = initialDelay * Math.pow(2, attempts - 1);
                            console.warn(`TTS API rate limit hit. Retrying in ${delay / 1000} seconds...`);
                            await new Promise(res => setTimeout(res, delay));
                        } else {
                            console.error("Error generating TTS:", error);
                            setIsLoading(false);
                            return;
                        }
                    }
                }
                console.error("Failed to generate TTS after multiple retries.");
                setIsLoading(false);
            };

            // Function to execute the commands entered by the user
            const runCommands = async () => {
                setMessage("Executing commands..."); // Update message
                // Split commands input by newline, trim whitespace, and filter out empty lines
                const commands = commandsInput.split('\n').map(cmd => cmd.trim()).filter(cmd => cmd !== '');
                
                let currentPos = { ...characterPos }; // Start with current robot position
                let currentDir = characterDir; // Start with current robot direction

                // Loop through each command
                for (let i = 0; i < commands.length; i++) {
                    const command = commands[i];
                    const parts = command.split(' '); // Split command into action and value
                    const action = parts[0].toLowerCase(); // Get the action (move, turn)

                    await new Promise(resolve => setTimeout(resolve, 500)); // Pause for 0.5 seconds for animation

                    let newPos = { ...currentPos }; // Temporary new position
                    let newDir = currentDir; // Temporary new direction
                    let validCommand = true; // Flag to track command validity

                    if (action === 'move') {
                        const steps = parseInt(parts[1], 10); // Get number of steps
                        if (isNaN(steps) || steps <= 0) { // Validate steps input
                            setMessage(`Oops! Invalid move command: "${command}". Please specify positive steps.`);
                            speakMessage(`Oops! Invalid move command. Try "move 1" or "move 2".`);
                            validCommand = false;
                            break; // Stop execution if command is invalid
                        }
                        for (let s = 0; s < steps; s++) {
                            const { dr, dc } = DIRECTIONS[newDir]; // Get row/column changes for current direction
                            newPos.r += dr; // Calculate new row
                            newPos.c += dc; // Calculate new column

                            // Check for out-of-bounds or wall collision
                            if (newPos.r < 0 || newPos.r >= GRID_SIZE ||
                                newPos.c < 0 || newPos.c >= GRID_SIZE ||
                                grid[newPos.r][newPos.c] === 1) { // Hit a wall (grid value 1)
                                setMessage(`Oops! Hit a wall at (${newPos.r}, ${newPos.c}). Try again!`);
                                speakMessage(`Oh no! You hit a wall! Let's try a different path.`);
                                validCommand = false;
                                break; // Stop execution if hit a wall
                            }
                            currentPos = { ...newPos }; // Update robot's position after each step
                            setCharacterPos({ ...currentPos }); // Update state to re-render robot
                            await new Promise(resolve => setTimeout(resolve, 200)); // Shorter pause for each step
                        }
                    } else if (action === 'turn') {
                        const direction = parts[1].toLowerCase(); // Get turn direction (left, right)
                        if (direction === 'left') {
                            newDir = (currentDir + 3) % 4; // Rotate counter-clockwise (0 -> 3, 1 -> 0, etc.)
                        } else if (direction === 'right') {
                            newDir = (currentDir + 1) % 4; // Rotate clockwise (0 -> 1, 1 -> 2, etc.)
                        } else {
                            setMessage(`Oops! Invalid turn direction: "${parts[1]}". Use "left" or "right".`);
                            speakMessage(`Hmm, I don't know that turn direction. Please say "turn left" or "turn right".`);
                            validCommand = false;
                            break; // Stop execution if turn direction is invalid
                        }
                        currentDir = newDir; // Update robot's direction
                        setCharacterDir(newDir); // Update state to re-render robot
                    } else {
                        setMessage(`Oops! Unknown command: "${command}". Use "move <steps>" or "turn <direction>".`);
                        speakMessage(`I don't understand "${command}". Please use "move" or "turn".`);
                        validCommand = false;
                        break; // Stop execution if command is unknown
                    }

                    if (!validCommand) break; // Break from loop if any command was invalid
                }

                // After all commands are executed or stopped due to error
                if (validCommand && currentPos.r === targetPos.r && currentPos.c === targetPos.c) {
                    setMessage("Hooray! You reached the star! ‚ú®");
                    speakMessage("Hooray! You reached the star! You're a super coder!");
                } else if (validCommand && !message.startsWith("Oops!") && !message.startsWith("Unknown command")) {
                    setMessage("Commands finished. Keep trying!");
                    speakMessage("Commands finished. You're almost there! Keep trying!");
                }
            };

            // Function to handle the "Back to Previous Page" action
            const handleBackToIndex = () => {
                window.history.back(); // Navigates to the previous page in history
            };

            return (
                <div ref={gameRef} className="min-h-screen bg-gradient-to-br from-blue-50 to-white flex flex-col items-center justify-center p-4 font-inter">
                    {/* Main game container */}
                    <div className="bg-white p-8 rounded-3xl shadow-2xl max-w-4xl w-full space-y-6">
                        <h1 className="text-4xl font-extrabold text-blue-700 text-center mb-4">
                            Code Journey for Kids! ü§ñ
                        </h1>
                        <p className="text-lg text-gray-800 text-center">
                            Help the robot reach the <span className="text-yellow-500 text-2xl">‚≠ê</span>!
                            Use commands like <code className="bg-blue-50 p-1 rounded-md">move 1</code> (to move one step) or <code className="bg-blue-50 p-1 rounded-md">turn left</code> / <code className="bg-blue-50 p-1 rounded-md">turn right</code>.
                        </p>

                        <div className="flex flex-col md:flex-row gap-6">
                            {/* Game Grid Section */}
                            <div className="flex-grow bg-white p-4 rounded-xl shadow-inner flex items-center justify-center min-h-[300px] aspect-square">
                                <div
                                    className="grid border-2 border-blue-300 w-full h-full"
                                    style={{
                                        gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`, // Responsive columns
                                        gridTemplateRows: `repeat(${GRID_SIZE}, 1fr)`,    // Responsive rows
                                    }}
                                >
                                    {grid.map((row, rIdx) =>
                                        row.map((cell, cIdx) => (
                                            <div
                                                key={`${rIdx}-${cIdx}`}
                                                className={`relative flex items-center justify-center text-xl sm:text-2xl md:text-3xl border border-blue-100 ${
                                                    cell === 1 ? 'bg-blue-200' : 'bg-blue-50'
                                                }`} // Wall or path cell
                                            >
                                                {/* Render robot if its position matches current cell */}
                                                {characterPos.r === rIdx && characterPos.c === cIdx && (
                                                    <span role="img" aria-label="robot" className="z-10 animate-bounce-slight">
                                                        ü§ñ
                                                    </span>
                                                )}
                                                {/* Render star if its position matches current cell */}
                                                {targetPos.r === rIdx && targetPos.c === cIdx && (
                                                    <span role="img" aria-label="star" className="absolute text-yellow-500 z-0">
                                                        ‚≠ê
                                                    </span>
                                                )}
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>

                            {/* Controls and Commands Section */}
                            <div className="w-full md:w-1/3 flex flex-col space-y-4">
                                <h2 className="text-2xl font-semibold text-gray-800">Your Code:</h2>
                                <textarea
                                    className="w-full p-3 border-2 border-blue-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-lg resize-y h-48 md:h-64"
                                    placeholder="Enter commands here, one per line:
move 2
turn right
move 1"
                                    value={commandsInput}
                                    onChange={(e) => setCommandsInput(e.target.value)} // Update commands input
                                ></textarea>
                                <div className="flex flex-col gap-3">
                                    <button
                                        onClick={runCommands}
                                        className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-200 flex items-center justify-center gap-2"
                                        disabled={isLoading} // Disable button while TTS is loading
                                    >
                                        {isLoading ? (
                                            // Loading spinner for TTS
                                            <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                        ) : (
                                            // Play icon for Run Code button
                                            <>
                                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-play"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                                Run Code
                                            </>
                                        )}
                                    </button>
                                    <button
                                        onClick={initializeGame} // Reset button calls initializeGame
                                        className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-200 flex items-center justify-center gap-2"
                                        disabled={isLoading} // Disable button while TTS is loading
                                    >
                                        {/* Reset icon for Reset Game button */}
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-rotate-ccw"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.76 2.75L3 8"/><path d="M3 3v5h5"/></svg>
                                        Reset Game
                                    </button>
                                    <button
  onClick={() => (window.location.href = "index.html")}
  className="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-200 flex items-center justify-center gap-2"
  disabled={isLoading} // Disable button while TTS is loading
>
  {/* Back icon for Back to Index button */}
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    className="lucide lucide-arrow-left"
  >
    <path d="m12 19-7-7 7-7" />
    <path d="M19 12H5" />
  </svg>
  Back to Index
</button>

                                </div>
                                {/* Display game messages to the user */}
                                <p className="mt-4 text-center text-xl font-semibold text-gray-800 bg-blue-100 p-3 rounded-lg shadow-inner">
                                    {message}
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Mount the React App component to the root div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
